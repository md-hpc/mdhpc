# High Performance Molecular Dynamics on CUDA
**Molecular dynamics** is a technique in computational biology that simulates physical systems of interest at the particle level: integrating intermolecular forces using simple Newtonian mechanics over a series of discrete timesteps. Providing a rich understanding of the structure and dynamics of subject systems, these simulations are of great interest to biologists, and their extreme computational demand makes their optimization of great interest to computer engineers. While MD has some characteristics that lend themselves well to the highly parallel architectures of today's accelerators, the dense matrix of interactions when computing the short-range non-bonded Lenard Jones potential makes optimization of MD a nontrivial task. In this project, we develop optimizations for MD on three accelerators: CPU, GPU, and FPGA. The GPU code for this project lives here.

## Project Structure
```
.
├── build                           # executables are built and stored here
│   ├── cell_list
│   ├── cell_list_n3l
│   ├── naive
│   ├── nsquared
│   ├── nsquared_n3l
│   └── nsquared_shared
├── include                         # header files
│   └── pdb_importer.h
├── input                           # input PDB files generated by generate_pdb.py
│   ├── n-3000.pdb                        # 3000 randomly generated particles
│   ├── random_particles-1024.pdb         # 1024 randomly generated particles
│   ├── random_particles-16384.pdb        # 16384 randomly generated particles
│   ├── random_particles-4096.pdb         # 4096 randomly generated particles
│   └── random_particles-65536.pdb        # 65536 randomly generated particles
├── Makefile
├── output                          # batch job outputs
│   ├── nsquared                           # each implementation has a separate directory, for each particle count there is csv, error, and output file
│   │   ├── ts-1_tsd-1e-15_n-3000_output.csv        # particle positions stored as csv
│   │   ├── ts-1_tsd-1e-15_n-3000_output_error.txt  # contains any errors that occur during the simulation
│   │   └── ts-1_tsd-1e-15_n-3000_output.txt        # contains info such as timing data
│   ├── nsquared_n3l
│   ├── nsquared_shared
│   ├── cell_list
│   └── cell_list_n3l
├── README.md
├── scripts                          # contains various scripts
│   ├── batch_job.sh                        # runs all jobs on the grid
│   ├── get_results.sh                      # gets results from output files
│   └── script_generator.sh                 # generates batch job scripts into the scripts directory and also generated batch_job.sh
└── src                              # implementations
    ├── cell_list.cu                        # cell list
    ├── cell_list_n3l.cu                    # cell list with N3L optimization
    ├── generate_pdb.py                     # PDB file generator
    ├── naive.c                             # C code for PoC
    ├── naive_with_cells.c                  # C code for PoC
    ├── nsquared.cu                         # N^2
    ├── nsquared_n3l.cu                     # N^2 with N3L optimization
    ├── nsquared_shared.cu                  # N^2 with shared memory optimization
    ├── pdb_importer.c                      # code for importing pdb files
    └── viz.py                              # creates a gif from output file for SIMULATION mode
```
## Installation
Prerequisites:
- CUDA 12.5
- NVIDIA GPU
- python3
    - matplotlib
    - numpy
### Generating testing PDB files
In the `src` directory, there is a python program called `generate_pdb.py`. Run this file with the given arguments to generate a pdb file of random particle positions: `-o output file name`, `-n number of particles`, `-x number of cells in the x direction`, same for `-y` and `-z`, `-c cell cutoff radius`
### Generating scripts for running batch jobs
`script_generator.sh` generates scripts used to submit non-interactive batch jobs through qsub on the Boston University Shared Computing Cluster (SCC). The parameters `PROJ_DIR`, `SCRIPTS_DIR`, `TIMESTEPS`, `TIMESTEP_DURATION`, `TYPE` can be changed easily depending on what the user wants to be simulated. Additionally, when the user wants to generate new scripts, the previous ones are replaced.   
### Generating executable for interactive use
For each implementation (nsquared, nsquared shared, nsquared n3l, cell list, cell list n3l), simply invoke the Makefile within the corresponding implementation to build the binary. For example to generate the executable for the naive implementation use the following command: make nsquared. Depending on attributes of the PDB file, the user may need to modify the variables in the Makefile named `NSQUARED_FLAGS` and `CELL_LIST_FLAGS`.
Running the executable for each implementation
The executables can be run by running `batch_job.sh` or through an interactive GPU job. `batch_job.sh` is also generated by `script_generator.sh`. If you are running executables on an interactive GPU, invoke it like so: `<implementation> <input pdb file> <output csv file>`.
### Generating visualizations of the simulations
 To generate a gif of the simulation, run `src/viz.py <axis length> <input csv file> <output gif file>`.

## Running CUDA
CUDA can be run on NVIDIA GPUs. For this project, A40 GPUs on the [BU Shared Computing Cluster](https://www.bu.edu/tech/support/research/system-usage/connect-scc/scc-ondemand/) are utilized.

### Running CUDA on the SCC
1. Login to an scc node.
2. Execute the command: `module load cuda/12.5` to load the NVIDIA sdk tools.
3. To compile CUDA code, execute the command: `nvcc <filename> -o <outfile>`
4. To run the executable, a GPU node is needed. [interactive](https://www.bu.edu/tech/support/research/system-usage/running-jobs/interactive-jobs/)/[batch](https://www.bu.edu/tech/support/research/system-usage/running-jobs/submitting-jobs/#job-options)

## Resources
[CUDA C++ Programming Guide](https://docs.nvidia.com/cuda/cuda-c-programming-guide/)

[CUDA in C/C++ on the SCC](https://www.bu.edu/tech/support/research/software-and-programming/gpu-computing/cuda-c/)
